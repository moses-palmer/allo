use crate::prelude::*;

use weru::database::entity;
use weru::futures::StreamExt;

use crate::db::values::{Timestamp, UID, URL};

/// A description of a request.
#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
#[entity(Requests)]
pub struct Request {
    /// The unique identifier.
    ///
    /// We want these to be generated by the database, so we use a plain
    /// integer.
    pub uid: i64,

    /// The user making the request.
    pub user_uid: UID,

    /// A short name.
    pub name: String,

    /// A description.
    pub description: String,

    /// The amount.
    pub amount: i64,

    /// A relevant URL.
    pub url: Option<URL>,

    /// The timestamp of this request.
    pub time: Timestamp,
}

impl Request {
    /// The SQL statement used to create a transaction with an automatic UID.
    const CREATE_WITH_AUTO_UID: &'static str =
        sql_from_file!("Request.create-with-auto-id");

    /// The SQL statement used to load all requests from a user.
    const READ_FOR_USER: &'static str = sql_from_file!("Request.read-for-user");

    /// The SQL statement used to load all requests from members of a family.
    const READ_FOR_FAMILY: &'static str =
        sql_from_file!("Request.read-for-family");

    /// Creates a transaction in the database, delegating selection of UID.
    ///
    /// # Arguments
    /// *  `tx` - The database transaction.
    /// *  `user_uid` - The user UID.
    /// *  `name` - A short name.
    /// *  `description` - A description.
    /// *  `amount` - The amount. This should generally be a positive value.
    /// *  `url` - An optional URL describing the request.
    /// *  `time` - The timestamp of the request.
    pub async fn create_with_auto_uid<'a>(
        tx: &mut Tx<'a>,
        user_uid: UID,
        name: String,
        description: String,
        amount: i64,
        url: Option<URL>,
        time: Timestamp,
    ) -> Result<Self, DatabaseError> {
        let mut stream = sqlx::query(Self::CREATE_WITH_AUTO_UID)
            .bind(user_uid.clone())
            .bind(name.clone())
            .bind(description.clone())
            .bind(amount)
            .bind(url.clone())
            .bind(time)
            .fetch(tx.as_mut());
        while let Some(row) = stream.next().await {
            let uid = row?.get::<<Self as Entity>::Key, _>(0);
            return Ok(Self {
                uid,
                user_uid,
                name,
                description,
                amount,
                url,
                time,
            });
        }

        Err(DatabaseError::RowNotFound)
    }

    /// Loads all requests for a user.
    ///
    /// # Arguments
    /// *  `tx` - The database transaction.
    /// *  `user_uid` - The user UID.
    pub async fn read_for_user<'a>(
        tx: &mut Tx<'a>,
        user_uid: &UID,
    ) -> Result<Vec<Self>, DatabaseError> {
        sqlx::query_as(Self::READ_FOR_USER)
            .bind(user_uid)
            .fetch_all(tx.as_mut())
            .await
    }

    /// Loads all requests for a family.
    ///
    /// # Arguments
    /// *  `tx` - The database transaction.
    /// *  `family_uid` - The family UID.
    pub async fn read_for_family<'a>(
        tx: &mut Tx<'a>,
        family_uid: &UID,
    ) -> Result<Vec<Self>, DatabaseError> {
        sqlx::query_as(Self::READ_FOR_FAMILY)
            .bind(family_uid)
            .fetch_all(tx.as_mut())
            .await
    }
}

entity_tests! {
    Request[i64 = i64::default()] {
        entity: |id| Request {
            uid: id,
            user_uid: UID::new(),
            name: "name".into(),
            description: "description".into(),
            amount: 42,
            url: None,
            time: Timestamp::now(),
        };
        modify: |e| Request {
            description: "another description".into(),
            ..e
        };
        prepare: |tx, e| {
            let u = crate::db::entities::user::tests::entity_with_id(
                e.user_uid.clone(),
            );
            crate::db::entities::user::tests::prepare(tx, &u).await?;
            u.create(tx.as_mut()).await
        };
    }
}

#[cfg(test)]
mod impl_tests {
    use crate::db::entities::create;
    use crate::db::test_engine;
    use crate::db::values::Role;

    #[actix_rt::test]
    async fn create_with_auto_uid() {
        use super::*;
        let database = test_engine().await;
        let mut conn = database.connection().await.unwrap();

        let family = create::family(&mut conn, "Family");
        let user = create::user(
            &mut conn,
            Role::Parent,
            "User 1",
            "test1@example.com",
            &family.uid,
        );
        let mut tx = conn.begin().await.unwrap();

        let request = Request::create_with_auto_uid(
            &mut tx,
            user.uid.clone(),
            "name".into(),
            "description".into(),
            42,
            None,
            Timestamp::now(),
        )
        .await
        .unwrap();

        assert_eq!(
            Some(&request),
            Request::read(tx.as_mut(), &request.uid)
                .await
                .unwrap()
                .as_ref(),
        );
    }

    #[actix_rt::test]
    async fn read_for_user() {
        use super::*;
        let database = test_engine().await;
        let mut conn = database.connection().await.unwrap();
        let family = create::family(&mut conn, "Family");
        let user1 = create::user(
            &mut conn,
            Role::Parent,
            "User 1",
            "test1@example.com",
            &family.uid,
        );
        let user2 = create::user(
            &mut conn,
            Role::Parent,
            "User 2",
            "test2@example.com",
            &family.uid,
        );
        let request1 = create::request(
            &mut conn,
            &user1.uid,
            "name1",
            "description1",
            42,
            "https://example.com/",
        );
        let request2 = create::request(
            &mut conn,
            &user1.uid,
            "name2",
            "description2",
            43,
            "https://example.com/",
        );
        create::request(
            &mut conn,
            &user2.uid,
            "name3",
            "description3",
            44,
            "https://example.com/",
        );
        let mut tx = conn.begin().await.unwrap();

        let requests = Request::read_for_user(&mut tx, &request1.user_uid)
            .await
            .unwrap();
        assert_eq!(requests.len(), 2);
        assert!(requests.contains(&request1));
        assert!(requests.contains(&request2));
    }

    #[actix_rt::test]
    async fn read_for_family() {
        use super::*;
        let database = test_engine().await;
        let mut conn = database.connection().await.unwrap();
        let family1 = create::family(&mut conn, "Family 1");
        let family2 = create::family(&mut conn, "Family 2");
        let user1 = create::user(
            &mut conn,
            Role::Parent,
            "User 1",
            "test1@example.com",
            &family1.uid,
        );
        let user2 = create::user(
            &mut conn,
            Role::Parent,
            "User 2",
            "test2@example.com",
            &family2.uid,
        );
        let request1 = create::request(
            &mut conn,
            &user1.uid,
            "name1",
            "description1",
            42,
            "https://example.com/",
        );
        let request2 = create::request(
            &mut conn,
            &user1.uid,
            "name2",
            "description2",
            43,
            "https://example.com/",
        );
        let request3 = create::request(
            &mut conn,
            &user1.uid,
            "name3",
            "description3",
            44,
            "https://example.com/",
        );
        create::request(
            &mut conn,
            &user2.uid,
            "name4",
            "description4",
            44,
            "https://example.com/",
        );
        let mut tx = conn.begin().await.unwrap();

        let requests = Request::read_for_family(&mut tx, &family1.uid)
            .await
            .unwrap();
        assert_eq!(requests.len(), 3);
        assert!(requests.contains(&request1));
        assert!(requests.contains(&request2));
        assert!(requests.contains(&request3));
    }
}
