use either::Either;
use futures::StreamExt;
use sqlx::prelude::*;

use crate::db::values::{Timestamp, UID, URL};

entity!(
    /// A description of a request.
    pub struct Request in Requests {
        /// The unique identifier.
        ///
        /// We want these to be generated by the database, so we use a plain
        /// integer.
        uid: i64,

        /// The user making the request.
        user_uid: UID,

        /// A short name.
        name: String,

        /// A description.
        description: String,

        /// The amount.
        amount: i64,

        /// A relevant URL.
        url: Option<URL>,

        /// The timestamp of this request.
        time: Timestamp,
    }
);

impl Request {
    /// The SQL statement used to create a transaction with an automatic UID.
    const CREATE_WITH_AUTO_UID: &'static str = concat!(
        "INSERT INTO Requests (user_uid, name, description, amount, url, time) \
        VALUES (",
        parameter!(user_uid),
        ", ",
        parameter!(name),
        ", ",
        parameter!(description),
        ", ",
        parameter!(amount),
        ", ",
        parameter!(url),
        ", ",
        parameter!(time),
        "); ",
        last_row_id!(),
    );

    /// The SQL statement used to load all requests from a user.
    const READ_FOR_USER: &'static str = concat!(
        "SELECT Requests.uid, user_uid, Requests.name, description, amount, \
            url, time \
        FROM Requests \
        WHERE user_uid = ",
        parameter!(user_uid),
    );

    /// The SQL statement used to load all requests from members of a family.
    const READ_FOR_FAMILY: &'static str = concat!(
        "SELECT Requests.uid, user_uid, Requests.name, description, amount, \
            url, time \
        FROM Requests \
        LEFT JOIN Users \
            ON Requests.user_uid = Users.uid \
        WHERE Users.family_uid = ",
        parameter!(user_uid),
    );

    /// Creates a transaction in the database, delegating selection of UID.
    ///
    /// # Arguments
    /// *  `e` - The database executor.
    /// *  `user_uid` - The user UID.
    /// *  `name` - A short name.
    /// *  `description` - A description.
    /// *  `amount` - The amount. This should generally be a positive value.
    /// *  `url` - An optional URL describing the request.
    /// *  `time` - The timestamp of the request.
    pub async fn create_with_auto_uid<'a, E>(
        e: E,
        user_uid: UID,
        name: String,
        description: String,
        amount: i64,
        url: Option<URL>,
        time: Timestamp,
    ) -> Result<Self, crate::db::Error>
    where
        E: ::sqlx::Executor<'a, Database = crate::db::Database>,
    {
        let mut stream = sqlx::query(Self::CREATE_WITH_AUTO_UID)
            .bind(user_uid.clone())
            .bind(name.clone())
            .bind(description.clone())
            .bind(amount)
            .bind(url.clone())
            .bind(time)
            .fetch_many(e);
        while let Some(e) = stream.next().await {
            if let Either::Right(row) = e? {
                let uid =
                    row.get::<<Self as crate::db::entities::Entity>::Key, _>(0);
                return Ok(Self {
                    uid,
                    user_uid,
                    name,
                    description,
                    amount,
                    url,
                    time,
                });
            }
        }

        Err(crate::db::Error::RowNotFound)
    }

    /// Loads all requests for a user.
    ///
    /// # Arguments
    /// *  `e` - The database executor.
    /// *  `user_uid` - The user UID.
    pub async fn read_for_user<'a, E>(
        e: E,
        user_uid: &UID,
    ) -> Result<Vec<Self>, crate::db::Error>
    where
        E: ::sqlx::Executor<'a, Database = crate::db::Database>,
    {
        sqlx::query_as(Self::READ_FOR_USER)
            .bind(user_uid)
            .fetch_all(e)
            .await
    }

    /// Loads all requests for a family.
    ///
    /// # Arguments
    /// *  `e` - The database executor.
    /// *  `family_uid` - The family UID.
    pub async fn read_for_family<'a, E>(
        e: E,
        family_uid: &UID,
    ) -> Result<Vec<Self>, crate::db::Error>
    where
        E: ::sqlx::Executor<'a, Database = crate::db::Database>,
    {
        sqlx::query_as(Self::READ_FOR_FAMILY)
            .bind(family_uid)
            .fetch_all(e)
            .await
    }
}

entity_tests! {
    Request[i64 = i64::default()] {
        entity: |id| Request {
            uid: id,
            user_uid: UID::new(),
            name: "name".into(),
            description: "description".into(),
            amount: 42,
            url: None,
            time: Timestamp::now(),
        };
        modify: |e| Request {
            description: "another description".into(),
            ..e
        };
        prepare: |c, e| {
            let u = crate::db::entities::user::tests::entity_with_id(
                e.user_uid().clone(),
            );
            crate::db::entities::user::tests::prepare(c, &u).await?;
            u.create(c).await
        };
    }
}

#[cfg(test)]
mod impl_tests {
    use actix_rt;

    use crate::db::entities::create;
    use crate::db::entities::Entity;
    use crate::db::test_pool;
    use crate::db::values::Role;

    use super::*;

    #[actix_rt::test]
    async fn create_with_auto_uid() {
        let pool = test_pool().await;
        {
            let mut c = pool.acquire().await.unwrap();

            let family = create::family(&mut c, "Family");
            let user = create::user(
                &mut c,
                Role::Parent,
                "User 1",
                "test1@example.com",
                family.uid(),
            );

            let request = Request::create_with_auto_uid(
                &mut c,
                user.uid().clone(),
                "name".into(),
                "description".into(),
                42,
                None,
                Timestamp::now(),
            )
            .await
            .unwrap();

            assert_eq!(
                Some(&request),
                Request::read(&mut c, request.uid()).await.unwrap().as_ref(),
            );
        }
    }

    #[actix_rt::test]
    async fn read_for_user() {
        let pool = test_pool().await;
        {
            let mut c = pool.acquire().await.unwrap();

            let family = create::family(&mut c, "Family");
            let user1 = create::user(
                &mut c,
                Role::Parent,
                "User 1",
                "test1@example.com",
                family.uid(),
            );
            let user2 = create::user(
                &mut c,
                Role::Parent,
                "User 2",
                "test2@example.com",
                family.uid(),
            );
            let request1 = create::request(
                &mut c,
                user1.uid(),
                "name1",
                "description1",
                42,
                "https://example.com/",
            );
            let request2 = create::request(
                &mut c,
                user1.uid(),
                "name2",
                "description2",
                43,
                "https://example.com/",
            );
            create::request(
                &mut c,
                user2.uid(),
                "name3",
                "description3",
                44,
                "https://example.com/",
            );

            let requests = Request::read_for_user(&mut c, request1.user_uid())
                .await
                .unwrap();
            assert_eq!(requests.len(), 2);
            assert!(requests.contains(&request1));
            assert!(requests.contains(&request2));
        }
    }

    #[actix_rt::test]
    async fn read_for_family() {
        let pool = test_pool().await;
        {
            let mut c = pool.acquire().await.unwrap();

            let family1 = create::family(&mut c, "Family 1");
            let family2 = create::family(&mut c, "Family 2");
            let user1 = create::user(
                &mut c,
                Role::Parent,
                "User 1",
                "test1@example.com",
                family1.uid(),
            );
            let user2 = create::user(
                &mut c,
                Role::Parent,
                "User 2",
                "test2@example.com",
                family2.uid(),
            );
            let request1 = create::request(
                &mut c,
                user1.uid(),
                "name1",
                "description1",
                42,
                "https://example.com/",
            );
            let request2 = create::request(
                &mut c,
                user1.uid(),
                "name2",
                "description2",
                43,
                "https://example.com/",
            );
            let request3 = create::request(
                &mut c,
                user1.uid(),
                "name3",
                "description3",
                44,
                "https://example.com/",
            );
            create::request(
                &mut c,
                user2.uid(),
                "name4",
                "description4",
                44,
                "https://example.com/",
            );

            let requests = Request::read_for_family(&mut c, family1.uid())
                .await
                .unwrap();
            assert_eq!(requests.len(), 3);
            assert!(requests.contains(&request1));
            assert!(requests.contains(&request2));
            assert!(requests.contains(&request3));
        }
    }
}
